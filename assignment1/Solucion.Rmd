---
title: "Solucion"
author: "Daniel Ranchal Parrado"
date: "`r Sys.Date()`"
output:
    html_notebook: default
    pdf_document: default
---

```{r}
require(tseries)
require(DAAG)
```

## Carga de los datos y preprocesamiento

Si se observa el contenido del fichero, se puede inferir que hay 5 observaciones por unidad de tiempo siendo cada línea una unidad de tiempo. El objetivo es predecir los dos siguientes valores de esta serie temporal.

```{r engine='bash', comment=''}
cat dataseries.dat
```

Primero se lee el fichero con la función scan A continuación se construye un objeto de serie temporal ts especificando los datos del fichero y la frecuencia de la serie, que en este caso es 5.

```{r}
serie <- scan("dataseries.dat")
serie.ts <- ts(serie, frequency = 5)
plot(serie.ts)
```

En el siguiente gráfico se puede observar la serie temporal descompuesta en tendencia, estacionalidad y el resto. En el resto se puede apreciar que la varianza apenas varía a lo largo de la serie. Por lo tanto no habría que aplicar transformaciones de tipo logarítmica a esta serie.

```{r}
serie.ts.decomposed <- decompose(serie.ts)
plot(serie.ts.decomposed)
```

## División del problema en entrenamiento y test

A continuación se procede a dividir el conjunto de datos en dos, uno para entrenamiento y otro para test. Siempre
se recomienda que el tamaño del conjunto de test tenga al menos el mismo tamaño que los valores siguientes que queremos predecir de la serie. Como en este caso se pide que se calculen los dos siguientes valores, se fijará un conjunto de test de dos elementos.
En el siguiente gráfico se puede ver en color negro los datos de entrenamiento y en color rojo los datos de test.


```{r}
test.size = 2

serie.ts.train <- serie.ts[1:(length(serie.ts) - test.size)]
serie.ts.train.time <- 1:length(serie.ts.train)

serie.ts.test <- serie.ts[(length(serie.ts) - test.size + 1):length(serie.ts)]
serie.ts.test.time <- (serie.ts.train.time[length(serie.ts.train.time)] + 1):(serie.ts.train.time[length(serie.ts.train.time)] + test.size)

plot.ts(serie.ts.train)
lines(serie.ts.test.time, serie.ts.test, col="red")
```

## Análisis de la serie

En esta sección se procede a analizar la serie de manera visual. Como se puede observar en la descomposición de la serie temporal, se aprecia tendencia en la serie temporal. Sin embargo, en las siguientes secciones se podrá ver en el gráfico ACF si estamos en lo cierto.

Respecto a la estacionalidad, en la componente "seasonal" se ha asumido una estacionalidad cada 5 unidades de tiempo, tal y como se ha especificado al crear el objeto ts. De todas maneras, habrá que comprobar esta hipótesis comprobando el gráfico ACF de la serie.

```{r}
plot(serie.ts.decomposed)
```

## Tendencia

Primero de todo, vamos a ver el gráfico de autocorrelación de la serie para comprobar que realmente existe tendencia en la serie. Como se puede observar, los valores en cada lag se reducen "lentamente", indicativo de que existe tendencia.

```{r}
acf(serie.ts.train)
```

Como se ha visto en la descomposición aditiva de la serie, la tendencia no es lineal y por lo tanto habrá que modelarla de otra manera. En este caso se va a estimar con un filtro de medias móviles y para evitar el problema que puede tener este método, los primeros y últimos n valores que no se pueden calcular se van a rellenar con el elemento n + 1 y el elemento longitud_serie - n - 1.

En este caso, como la porción de test que se ha elegido son de dos elementos, estos se van a estimar con el último valor estimado de la tendencia en el conjunto de datos de entrenamiento


```{r}
k <- 2
filtro <- rep(
    1/((k*2) + 1),
    (k*2) + 1
)

trend.estimated.train <- filter(serie.ts.train, filter = filtro, sides = 2, method = "convolution")

# Manteniendo el valor más próximo
trend.estimated.train[1:k] <- trend.estimated.train[k+1]
trend.estimated.train[(length(trend.estimated.train) - 1):length(trend.estimated.train)] <- trend.estimated.train[length(trend.estimated.train) - k]

trend.estimated.test <- ts(
    rep(
        trend.estimated.train[length(trend.estimated.train)],
        test.size
    ),
    start = length(trend.estimated.train) + 1,
    end = length(trend.estimated.train) + 2
)

# Regresión lineal y dando el valor mas próximo para test

first_n_lm <- lm(serie.ts.train[1:(k+1)] ~ serie.ts.train.time[1:(k+1)])
trend.estimated.train[1] <- first_n_lm$fitted.values[1]
trend.estimated.train[2] <- first_n_lm$fitted.values[2]

last_n_lm <- lm(
    serie.ts.train[(length(serie.ts.train) - k):length(serie.ts.train)] ~ serie.ts.train.time[(length(serie.ts.train) - k):length(serie.ts.train)]
)
trend.estimated.train[length(serie.ts.train) - 1] <- last_n_lm$fitted.values[2]
trend.estimated.train[length(serie.ts.train)] <- last_n_lm$fitted.values[3]

trend.estimated.test <- last_n_lm$coefficients[1] + serie.ts.test.time*last_n_lm$coefficients[2]

plot.ts(serie.ts.train, xlim=c(1, serie.ts.test.time[length(serie.ts.test.time)]))
lines(serie.ts.train.time, trend.estimated.train, col="blue")
lines(serie.ts.test.time, serie.ts.test, col="red")
lines(serie.ts.test.time, trend.estimated.test, col="green")
```

No existen diferencias significativas en los errores de train y test cuando se modela la tendencia con un filtro de medias móviles.


```{r}
jarque.bera.test(trend.estimated.train - serie.ts.train)
jarque.bera.test(trend.estimated.test - serie.ts.test)
t.test(c(trend.estimated.train - serie.ts.train, trend.estimated.test - serie.ts.test))
```


A continuación se procede a eliminar la tendencia de la serie

```{r}
serie.ts.train.without.trend <- serie.ts.train - trend.estimated.train
serie.ts.test.without.trend <- serie.ts.test - trend.estimated.test

plot.ts(
    serie.ts.train.without.trend,
    xlim=c(1, serie.ts.test.time[length(serie.ts.test.time)]),
    ylim=c(-1.5, 2)
)
lines(serie.ts.test.time, serie.ts.test.without.trend, col="red")
```

A continuación se procede a revisar el gráfico ACF de la serie para ver si se ha eliminado correctamente la tendencia de la serie, y por lo tanto, se ha modelado bien.


```{r}
acf(serie.ts.train.without.trend)
```


## Estacionalidad

```{r}
#seasonality_feature <- decompose(serie.ts)$seasonal

#serie.ts.train.without.trend.season <- serie.ts.train.without.trend - seasonality_feature[1:length(serie.ts.train.without.trend)]

#serie.ts.test.without.trend.season <- serie.ts.test.without.trend - seasonality_feature[(length(serie.ts.train.without.trend) + 1):length(serie.ts)]

#plot.ts(
#    serie.ts.train.without.trend.season,
#    xlim=c(1, serie.ts.test.time[length(serie.ts.test.time)])
#)
#lines(serie.ts.test.time, serie.ts.test.without.trend.season, col="red")
```

## Estacionareidad

```{r}
adf.test(serie.ts.train.without.trend)
acf(serie.ts.train.without.trend)

#serie.ts.train.without.trend.diff <- diff(serie.ts.train.without.trend)
#adf.test(serie.ts.train.without.trend.diff)
#acf(serie.ts.train.without.trend.diff)
```

# Modelo ARIMA

p -> 4
d-> 0
q -> 4

```{r}
acf(serie.ts.train.without.trend)
pacf(serie.ts.train.without.trend)
```

```{r}
arima.model <- arima(
    serie.ts.train.without.trend,
    order = c(4, 0, 4)
)

valoresAjustados <- serie.ts.train.without.trend + arima.model$residuals

predictions <- predict(arima.model, n.ahead = 2)$pred

errorTrain <- sum((arima.model$residuals)^2)
errorTest <- sum((predictions - serie.ts.test.without.trend)^2)
```


```{r}
plot.ts(
    serie.ts.train.without.trend,
    xlim=c(1, serie.ts.test.time[length(serie.ts.test.time)]),
    ylim=c(-2, 2)
)
lines(valoresAjustados, col="blue")
lines(serie.ts.test.time, serie.ts.test.without.trend, col="red")
lines(serie.ts.test.time, predictions, col="blue")
```

```{r}
Box.test(arima.model$residuals)
jarque.bera.test(arima.model$residuals)
shapiro.test(arima.model$residuals)
hist(arima.model$residuals, col="blue", prob=T)
lines(density(arima.model$residuals))
```

Modelando tendencia con medias moviles (MA-3) (valores NA se rellenan con el más proximo) y un 6, 0, 3 en arima AIC -> 16.05643
Error train -> 4.635024
Error test -> 4.737994

Modelando tendencia con medias moviles (MA-5) (regresion lineal para los extremos y valor más proximo para test) y un 4, 0, 4 en arima AIC -> 92.87415
Error train -> 10.71614
Error test -> 0.4067225

Modelando tendencia con medias moviles (MA-5) (los valores NA se rellenan con el más proximo. Test se queda con los valores del último) y un 3,0,3 en arima AIC -> 100.1031


