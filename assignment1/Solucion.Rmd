---
title: "Solucion"
author: "Daniel Ranchal Parrado"
date: "`r Sys.Date()`"
output:
    html_notebook: default
    pdf_document: default
---

```{r}
require(tseries)
require(DAAG)
```

## Carga de los datos y preprocesamiento

Si se observa el contenido del fichero, se puede inferir que hay 5 observaciones por unidad de tiempo siendo cada línea una unidad de tiempo. El objetivo es predecir los dos siguientes valores de esta serie temporal.

```{r engine='bash', comment=''}
cat dataseries.dat
```

Primero se lee el fichero con la función scan. A continuación se construye un objeto de serie temporal ts especificando los datos del fichero y la frecuencia de la serie, que en principio asumimos que es 5.

```{r}
serie <- scan("dataseries.dat")
serie.ts <- ts(serie, frequency = 5)
plot(serie.ts)
```

En el siguiente gráfico se puede observar la serie temporal descompuesta en tendencia, estacionalidad y el componente irregular. En el resto se puede apreciar que la varianza apenas varía a lo largo de la serie. Por lo tanto no habría que aplicar transformaciones de tipo logarítmica a esta serie.

```{r}
serie.ts.decomposed <- decompose(serie.ts)
plot(serie.ts.decomposed)
```

## División del problema en entrenamiento y test

A continuación se procede a dividir el conjunto de datos en dos, uno para entrenamiento y otro para test. Siempre
se recomienda que el tamaño del conjunto de test tenga al menos el mismo tamaño que los valores siguientes que queremos predecir de la serie. Como en este caso se pide que se calculen los dos siguientes valores, se fijará un conjunto de test de dos elementos.
En el siguiente gráfico se puede ver en color negro los datos de entrenamiento y en color rojo los datos de test.


```{r}
test.size = 2

serie.ts.train <- serie.ts[1:(length(serie.ts) - test.size)]
serie.ts.train.time <- 1:length(serie.ts.train)

serie.ts.test <- serie.ts[(length(serie.ts) - test.size + 1):length(serie.ts)]
serie.ts.test.time <- (serie.ts.train.time[length(serie.ts.train.time)] + 1):(serie.ts.train.time[length(serie.ts.train.time)] + test.size)

plot.ts(serie.ts.train)
lines(serie.ts.test.time, serie.ts.test, col="red")
```

## Análisis de la serie

En esta sección se procede a analizar la serie de manera visual. Como se puede observar en la descomposición de la serie temporal, se aprecia tendencia en la serie temporal. Sin embargo, en las siguientes secciones se podrá ver en el gráfico ACF si estamos en lo cierto.

Respecto a la estacionalidad, en la componente "seasonal" se ha asumido una estacionalidad cada 5 unidades de tiempo, tal y como se ha especificado al crear el objeto ts. De todas maneras, habrá que comprobar esta hipótesis comprobando el gráfico ACF de la serie.

```{r}
plot(serie.ts.decomposed)
```

### Tendencia

Primero de todo, vamos a ver el gráfico de autocorrelación de la serie para comprobar que realmente existe tendencia en ella. Como se puede observar, los valores en cada lag se reducen "lentamente", indicativo de que existe tendencia.

```{r}
acf(serie.ts.train)
```

Como se ha visto en la descomposición aditiva de la serie, la tendencia no es lineal y por lo tanto habrá que modelarla de otra manera. En este caso se va a estimar con un filtro de medias móviles con k = 1 y con k = 2. Para evitar el problema que puede tener este método con los primeros y últimos k valores que no se pueden calcular se van a proponer los siguientes métodos:

- rellenar con el elemento k + 1 y el elemento longitud_serie - k - 1 respectivamente.
- rellenar los primeros k elementos con una regresión lineal desde el primer elemento hasta el elemento k + 1. Lo mismo para los k elementos del final con una regresión lineal desde el elemento longitud_serie - k - 1 hasta el elemento longitud_serie.
- Hibridación de los dos últimos

Para poder calcular la tendencia en el conjunto de test teniendo en cuenta los datos de entrenamiento y que el tamaño de test es de 2 (por lo tanto no se pueden calcular medias móviles), se han propuesto dos alternativas:

- Rellenar los valores de la tendencia con el último valor de la tendencia de train
- Utilizar la regresión lineal que se ha construido con los últimos valores de la serie en train para predecirlos en test


```{r}
# Function to get MA-(k*2 + 1) of a series
ma.series <- function(series, k) {
    filtro <- rep(
        1/((k*2) + 1),
        (k*2) + 1
    )
    
    return(filter(series, filter = filtro, sides = 2, method = "convolution"))
}

# Function to plot original series and trend of the series for train and test
plot.ma.series <- function(
        train_series,
        test_series,
        train_trend,
        test_trend,
        train_times,
        test_times
) {
    plot.ts(train_series, xlim=c(1, test_times[length(test_times)]))
    lines(train_times, train_trend, col="blue")
    lines(test_times, test_series, col="red")
    lines(test_times, test_trend, col="green")
}

# Function to check the hypothesis of the trend
trend.check.hypothesis <- function(
    train_series,
    test_series,
    train_trend,
    test_trend
) {
    print(jarque.bera.test(train_trend - train_series))
    print(jarque.bera.test(test_trend - test_series))
    print(t.test(c(train_trend - train_series, test_trend - test_series)))
}
```


```{r}
# MA-3 manteniendo valores próximos
k.h1 <- 1

trend.estimated.train.h1 <- ma.series(serie.ts.train, k.h1)

trend.estimated.train.h1[1:k.h1] <- trend.estimated.train.h1[k.h1+1]
trend.estimated.train.h1[(length(trend.estimated.train.h1) - 1):length(trend.estimated.train.h1)] <- trend.estimated.train.h1[length(trend.estimated.train.h1) - k.h1]

trend.estimated.test.h1 <- ts(
    rep(
        trend.estimated.train.h1[length(trend.estimated.train.h1)],
        test.size
    ),
    start = length(trend.estimated.train.h1) + 1,
    end = length(trend.estimated.train.h1) + 2
)

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h1,
    trend.estimated.test.h1,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h1,
    trend.estimated.test.h1
)

serie.ts.train.without.trend.h1 <- serie.ts.train - trend.estimated.train.h1
serie.ts.test.without.trend.h1 <- serie.ts.test - trend.estimated.test.h1
```

```{r}
# MA-5 manteniendo valores próximos
k.h2 <- 2

trend.estimated.train.h2 <- ma.series(serie.ts.train, k.h2)

trend.estimated.train.h2[1:k.h2] <- trend.estimated.train.h2[k.h2+1]
trend.estimated.train.h2[(length(trend.estimated.train.h2) - 1):length(trend.estimated.train.h2)] <- trend.estimated.train.h2[length(trend.estimated.train.h2) - k.h2]

trend.estimated.test.h2 <- ts(
    rep(
        trend.estimated.train.h2[length(trend.estimated.train.h2)],
        test.size
    ),
    start = length(trend.estimated.train.h2) + 1,
    end = length(trend.estimated.train.h2) + 2
)

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h2,
    trend.estimated.test.h2,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h2,
    trend.estimated.test.h2
)

serie.ts.train.without.trend.h2 <- serie.ts.train - trend.estimated.train.h2
serie.ts.test.without.trend.h2 <- serie.ts.test - trend.estimated.test.h2
```

```{r}
# MA-3 regresión lineal para los k valores del principio y del final
k.h3 <- 1

trend.estimated.train.h3 <- ma.series(serie.ts.train, k.h3)

# regresión utilizando los 3 primeros valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
first_n_lm <- lm(serie.ts.train[1:(k.h3+2)] ~ serie.ts.train.time[1:(k.h3+2)])
trend.estimated.train.h3[1] <- first_n_lm$fitted.values[1]

# regresión utilizando los 3 ultimos valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
last_n_lm <- lm(
    serie.ts.train[(length(serie.ts.train) - k.h3 - 1):length(serie.ts.train)] ~ serie.ts.train.time[(length(serie.ts.train) - k.h3 - 1):length(serie.ts.train)]
)
trend.estimated.train.h3[length(serie.ts.train)] <- last_n_lm$fitted.values[3]

# prediccion test con la regresión lineal de los ultimos k valores
trend.estimated.test.h3 <- last_n_lm$coefficients[1] + serie.ts.test.time*last_n_lm$coefficients[2]

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h3,
    trend.estimated.test.h3,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h3,
    trend.estimated.test.h3
)

serie.ts.train.without.trend.h3 <- serie.ts.train - trend.estimated.train.h3
serie.ts.test.without.trend.h3 <- serie.ts.test - trend.estimated.test.h3
```

```{r}
# MA-5 regresión lineal para los k valores del principio y del final
k.h4 <- 2

trend.estimated.train.h4 <- ma.series(serie.ts.train, k.h4)

# regresión utilizando los 3 primeros valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
first_n_lm <- lm(serie.ts.train[1:(k.h4+1)] ~ serie.ts.train.time[1:(k.h4+1)])
trend.estimated.train.h4[1] <- first_n_lm$fitted.values[1]
trend.estimated.train.h4[2] <- first_n_lm$fitted.values[2]

# regresión utilizando los 3 ultimos valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
last_n_lm <- lm(
    serie.ts.train[(length(serie.ts.train) - k.h4 - 1):length(serie.ts.train)] ~ serie.ts.train.time[(length(serie.ts.train) - k.h4 - 1):length(serie.ts.train)]
)
trend.estimated.train.h4[length(serie.ts.train) - 1] <- last_n_lm$fitted.values[2]
trend.estimated.train.h4[length(serie.ts.train)] <- last_n_lm$fitted.values[3]

# prediccion test con la regresión lineal de los ultimos k valores
trend.estimated.test.h4 <- last_n_lm$coefficients[1] + serie.ts.test.time*last_n_lm$coefficients[2]

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h4,
    trend.estimated.test.h4,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h4,
    trend.estimated.test.h4
)

serie.ts.train.without.trend.h4 <- serie.ts.train - trend.estimated.train.h4
serie.ts.test.without.trend.h4 <- serie.ts.test - trend.estimated.test.h4
```

```{r}
# MA-3 regresión lineal para los k valores del final. Mantener valores en el principio
k.h5 <- 1

trend.estimated.train.h5 <- ma.series(serie.ts.train, k.h5)
trend.estimated.train.h5[1:k.h5] <- trend.estimated.train.h5[k.h5+1]

# regresión utilizando los 3 ultimos valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
last_n_lm <- lm(
    serie.ts.train[(length(serie.ts.train) - k.h5 - 1):length(serie.ts.train)] ~ serie.ts.train.time[(length(serie.ts.train) - k.h5 - 1):length(serie.ts.train)]
)
trend.estimated.train.h5[length(serie.ts.train)] <- last_n_lm$fitted.values[3]

# prediccion test con la regresión lineal de los ultimos k valores
trend.estimated.test.h5 <- last_n_lm$coefficients[1] + serie.ts.test.time*last_n_lm$coefficients[2]

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h5,
    trend.estimated.test.h5,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h5,
    trend.estimated.test.h5
)

serie.ts.train.without.trend.h5 <- serie.ts.train - trend.estimated.train.h5
serie.ts.test.without.trend.h5 <- serie.ts.test - trend.estimated.test.h5
```

```{r}
# MA-5 regresión lineal para los k valores del final. Mantener valores en el principio
k.h6 <- 2

trend.estimated.train.h6 <- ma.series(serie.ts.train, k.h6)
trend.estimated.train.h6[1:k.h6] <- trend.estimated.train.h6[k.h6+1]

# regresión utilizando los 3 ultimos valores
# Cuando k=1 -> 3 valores
# Cuando k=2 -> 3 valores
# Cuando k=3 -> 4 valores
last_n_lm <- lm(
    serie.ts.train[(length(serie.ts.train) - k.h6 - 1):length(serie.ts.train)] ~ serie.ts.train.time[(length(serie.ts.train) - k.h6 - 1):length(serie.ts.train)]
)
trend.estimated.train.h6[length(serie.ts.train) - 1] <- last_n_lm$fitted.values[2]
trend.estimated.train.h6[length(serie.ts.train)] <- last_n_lm$fitted.values[3]

# prediccion test con la regresión lineal de los ultimos k valores
trend.estimated.test.h6 <- last_n_lm$coefficients[1] + serie.ts.test.time*last_n_lm$coefficients[2]

plot.ma.series(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h6,
    trend.estimated.test.h6,
    serie.ts.train.time,
    serie.ts.test.time
)

trend.check.hypothesis(
    serie.ts.train,
    serie.ts.test,
    trend.estimated.train.h6,
    trend.estimated.test.h6
)

serie.ts.train.without.trend.h6 <- serie.ts.train - trend.estimated.train.h6
serie.ts.test.without.trend.h6 <- serie.ts.test - trend.estimated.test.h6
```

Como se pueden ver en todas las hipótesis, no existen diferencias significativas en los errores de train y test cuando se modela la tendencia con cada hipótesis.

A continuación se procede a observar los ACF de cada hipótesis para observar si se ha borrado y modelado correctamente la tendencia

```{r}
acf(serie.ts.train.without.trend.h1)
acf(serie.ts.train.without.trend.h2)
acf(serie.ts.train.without.trend.h3)
acf(serie.ts.train.without.trend.h4)
acf(serie.ts.train.without.trend.h5)
acf(serie.ts.train.without.trend.h6)
```

Visualmente se puede observar que se ha eliminado ese escalonado que existía anteriormente a borrar la tendencia de la serie original. Por lo tanto, por el momento se pueden dar por válidas todas las hipótesis.


## Estacionalidad

Revisando todos los ACF anteriores donde se ha eliminado la tendencia no se observa en ningún momento ningún patrón que
se repita cada x tiempo, por lo tanto no se va a modelar la estacionalidad.

Aunque al principio se estableció a priori una frecuencia de 5 en los datos y el gráfico que generaba STL decía una estacionalidad cada 5, esto se debe principalmente a la frecuencia arbitraria que se fijó al principio.

De todas maneras, en la siguiente sección donde se comprueba si la serie actual es estacionaria se podrá ver si se ha cometido algún error diciendo que la serie no tiene una componente estacional.

## Estacionareidad

En esta sección se comprueba si la serie es estacionaria, lo cual es indispensable si queremos entrenar un modelo ARIMA donde se especifica el order p, d, q.

Las series estacionarias son aquellas cuyas propiedades no dependen del momento en el que se observa la serie. Por lo tanto, por su definición, las series estacionarias no contienen ni tendencia ni estacionalidad.

Para comprobar que realmente estamos ante una serie estacionaria, se ejecuta el test estadístico de Dickey-Fuller aumentado. Si el p-value es menor que 0.05 estamos ante una serie estacionaria mientras que en el caso contrario, no lo sería y habría que diferenciar para obtener una serie de este tipo.

A continuación se prueban las diferentes series temporales que se han obtenido con cada hipótesis

```{r}
adf.test(serie.ts.train.without.trend.h1)
adf.test(serie.ts.train.without.trend.h2)
adf.test(serie.ts.train.without.trend.h3)
adf.test(serie.ts.train.without.trend.h4)
adf.test(serie.ts.train.without.trend.h5)
adf.test(serie.ts.train.without.trend.h6)
```

En este caso, todas las series temporales generadas por cada hipótesis son estacionarias, por lo que la hipótesis de que no había estacionalidad era real. Una vez que se sabe que son estacionarias, se procede a entrenar los modelos arima.

# Modelo ARIMA

p -> 6
d-> 0
q -> 3

```{r}
acf(serie.ts.train.without.trend)
pacf(serie.ts.train.without.trend)
```

```{r}
arima.model <- arima(
    serie.ts.train.without.trend,
    order = c(6, 0, 3)
)

valoresAjustados <- serie.ts.train.without.trend + arima.model$residuals

predictions <- predict(arima.model, n.ahead = 2)$pred

errorTrain <- sum((arima.model$residuals)^2)
errorTest <- sum((predictions - serie.ts.test.without.trend)^2)
```


```{r}
plot.ts(
    serie.ts.train.without.trend,
    xlim=c(1, serie.ts.test.time[length(serie.ts.test.time)]),
    ylim=c(-2, 3)
)
lines(valoresAjustados, col="blue")
lines(serie.ts.test.time, serie.ts.test.without.trend, col="red")
lines(serie.ts.test.time, predictions, col="blue")
```


```{r}
Box.test(arima.model$residuals)
jarque.bera.test(arima.model$residuals)
shapiro.test(arima.model$residuals)
hist(arima.model$residuals, col="blue", prob=T)
lines(density(arima.model$residuals))
```

Modelando tendencia con medias moviles (MA-3) (valores NA se rellenan con el más proximo) y un 6, 0, 3 en arima AIC -> 16.05643
Error train -> 4.635024
Error test -> 4.737994

Modelando tendencia con medias moviles (MA-5) (regresion lineal para los extremos y valor más proximo para test) y un 4, 0, 4 en arima AIC -> 92.87415
Error train -> 10.71614
Error test -> 0.4067225

Modelando tendencia con medias moviles (MA-5) (los valores NA se rellenan con el más proximo. Test se queda con los valores del último) y un 3,0,3 en arima AIC -> 100.1031
Error train -> 12.617510
Error test -> 14.983722

Modelando tendencia con medias moviles (MA-3) (valores NA se rellenan con el más proximo en el principio, regresion lineal para el ultimo valor y test) y un 6, 0, 3 en arima AIC -> 14.86745
Error train -> 4.5593
Error test -> 0.3562

## Predicción de los dos siguientes valores

```{r}
k <- 1
filtro <- rep(
    1/((k*2) + 1),
    (k*2) + 1
)

trend.estimated <- filter(serie.ts, filter = filtro, sides = 2, method = "convolution")

trend.estimated[1] <- trend.estimated[2]
serie.ts.time <- 1:length(serie.ts)

last_n_lm <- lm(
    serie.ts[(length(serie.ts) - 2):length(serie.ts)] ~ serie.ts.time[(length(serie.ts) - 2):length(serie.ts)]
)
trend.estimated[length(serie.ts)] <- last_n_lm$fitted.values[3]

serie.ts.without.trend <- serie.ts - trend.estimated

arima.model.final <- arima(
    serie.ts.without.trend,
    order = c(6, 0, 3)
)

final.predictions <- predict(arima.model.final, n.ahead = 2)$pred

plot.ts(
    serie.ts.without.trend[1:96],
    xlim=c(1, serie.ts.time[length(serie.ts.time)]),
    ylim=c(-2, 2)
)
valoresAjustados <- serie.ts.without.trend + arima.model.final$residuals
lines(valoresAjustados[1:96], col="blue")
lines(97:98, final.predictions, col="blue")
```

Las predicciones de los dos valores siguientes son: 580.1536 580.3910

El AIC del modelo final es 16.47838

```{r}
trend.estimated.prediction <- last_n_lm$coefficients[1] + c(97, 98)*last_n_lm$coefficients[2]

predictions.with.trend <- final.predictions + trend.estimated.prediction

plot.ts(
    serie.ts[1:96]
)
lines(97:98, predictions.with.trend, col="blue")
```


